use std::collections::HashMap;
use std::fs::{File, read_to_string};
use std::path::PathBuf;

use mdbook_markdown::pulldown_cmark::{Event, Tag};
use mdbook_markdown::{MarkdownOptions, new_cmark_parser};
use mdbook_preprocessor::book::{Book, Chapter};
use mdbook_preprocessor::errors::Result;
use mdbook_preprocessor::{Preprocessor, PreprocessorContext};
use pulldown_cmark_to_cmark::cmark;

mod issue_link;
use issue_link::link_issues;
mod remap;
use remap::Remapper;

/// A mdbook preprocessor for typst-extra-docs.
pub struct ExtraDocs;
impl ExtraDocs {
    #[expect(clippy::new_without_default)]
    pub fn new() -> ExtraDocs {
        ExtraDocs
    }
}

/// `meta.json` generated by `download.py`.
#[derive(serde::Deserialize)]
struct Metadata {
    /// A mapping from file paths to source URLs.
    map: HashMap<PathBuf, String>,
    /// A mapping from source URL prefixes to author dates.
    dates: HashMap<String, String>,
}

impl Preprocessor for ExtraDocs {
    fn name(&self) -> &str {
        "typst-extra-docs"
    }

    fn run(&self, ctx: &PreprocessorContext, mut book: Book) -> Result<Book> {
        // Read data generated by `download.py`
        let meta = ctx.config.book.src.join("meta.json");
        let meta: Metadata = serde_json::from_reader(File::open(&meta).inspect_err(|e| {
            eprintln!("Failed to open {:?}: {e:?}", &meta);
        })?)?;

        let remapper = Remapper::new(&meta.map);

        book.for_each_chapter_mut(|chapter| {
            let Some(file) = &chapter.source_path else {
                return; // Skip draft chapters
            };
            let Some(source_url) = meta.map.get(file) else {
                return; // Skip chapters not generated by `download.py`
            };

            let markdown_options = MarkdownOptions::default();
            // Ignore markdown options in `book.toml` for simplicity.

            // 1. Remap links.
            // This has to be the first step, because links in later steps should not be remapped.
            match remap_links(chapter, file, &remapper, &markdown_options) {
                Ok(s) => chapter.content = s,
                Err(e) => eprintln!("failed to process chapter: {e:?}"),
            }

            // 2. Add source URL notice.
            // This step should be executed before adding the prelude, because the notice uses the word _following_ and should be put after the prelude.
            {
                let author_date = meta
                    .dates
                    .iter()
                    .find_map(|(prefix, author_date)| {
                        source_url.starts_with(prefix).then_some(author_date)
                    })
                    .unwrap_or_else(|| {
                        panic!("No matching author date found for source URL: {source_url}");
                    });
                chapter.content = add_source_notice(&chapter.content, source_url, author_date);
            }

            // 3. Add the prelude.
            {
                let prelude = ctx.config.book.src.join(file.with_extension("prelude.md"));
                match read_to_string(&prelude) {
                    Ok(prelude) => {
                        chapter.content = format!("{}\n\n{}", prelude, chapter.content);
                    }
                    Err(e) if e.kind() == std::io::ErrorKind::NotFound => {}
                    Err(e) => panic!("Failed to read {:?}: {e:?}", &prelude),
                }
            }

            // 4. Link issues.
            match link_issues(&chapter.content, source_url, &markdown_options) {
                Ok(Some(s)) => chapter.content = s,
                Ok(None) => {}
                Err(e) => eprintln!("Failed to link an issue: {e:?}"),
            }
        });

        Ok(book)
    }

    fn supports_renderer(&self, renderer: &str) -> Result<bool> {
        Ok(renderer != "not-supported")
    }
}

/// Add a source URL notice to the chapter and return the new content.
fn add_source_notice(chapter_content: &str, source_url: &str, author_date: &str) -> String {
    format!(
        r#"> [!NOTE]
> The following is an _unofficial_ copy of [the file in Typst's official repository]({source_url}) as of {author_date}.

{}"#,
        chapter_content
    )
}

/// Remap links in a chapter to correct relative URLs.
fn remap_links(
    chapter: &Chapter,
    source_file: &PathBuf,
    remapper: &Remapper,
    markdown_options: &MarkdownOptions,
) -> Result<String> {
    let events = new_cmark_parser(&chapter.content, markdown_options).map(|event| match event {
        Event::Start(Tag::Link {
            link_type,
            dest_url,
            title,
            id,
        }) => Event::Start(Tag::Link {
            link_type,
            dest_url: remapper
                .remap_link(dest_url.clone(), source_file)
                .unwrap_or(dest_url),
            title,
            id,
        }),
        _ => event,
    });

    let mut buf = String::with_capacity(chapter.content.len());
    Ok(cmark(events.into_iter(), &mut buf).map(|_| buf)?)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_options() {
        /*
           original_md  ---→ (pulldown_cmark::html) original_html
               |                                         ↑
               | (pulldown_cmark_to_cmark)               | (should be equal)
               ↓                                         ↓
           processed_md ---→ (pulldown_cmark::html) processed_html

           `normalize_markdown` in `download.py` should make sure `original_html == processed_html`.
        */

        use mdbook_markdown::pulldown_cmark::html;

        let original_md = r"# Test

| Variant     | Example                                              |
|-------------|------------------------------------------------------|
| **String:** | `thesis`                                             |
| **Macro:**  | `Thesis`                                             |

- Add a symlink from `$XDG_DATA_HOME/typst/packages/preview` to the `preview`
  folder of your fork of this repository (see the documentation on [local packages]).

[local packages]: ../README.md#local-packages";

        let events = new_cmark_parser(original_md, &MarkdownOptions::default());
        let mut original_html = String::new();
        html::push_html(&mut original_html, events);

        let events = new_cmark_parser(original_md, &MarkdownOptions::default());
        let mut processed_md = String::new();
        cmark(events, &mut processed_md).unwrap();

        let events = new_cmark_parser(&processed_md, &MarkdownOptions::default());
        let mut processed_html = String::new();
        html::push_html(&mut processed_html, events);

        eprintln!(
            r"Original markdown:
{original_md}

Processed markdown:
{processed_md}

Original HTML:
{original_html}

Processed HTML:
{processed_html}"
        );
        assert_eq!(original_html, processed_html);
    }
}
