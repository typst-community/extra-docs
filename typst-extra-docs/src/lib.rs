use std::fs::File;
use std::path::PathBuf;

use mdbook_preprocessor::book::{Book, Chapter};
use mdbook_preprocessor::errors::Result;
use mdbook_preprocessor::{Preprocessor, PreprocessorContext};

/// A mdbook preprocessor for typst-extra-docs.
pub struct ExtraDocs;
impl ExtraDocs {
    #[expect(clippy::new_without_default)]
    pub fn new() -> ExtraDocs {
        ExtraDocs
    }
}

/// `meta.json` generated by `download.py`.
#[derive(serde::Deserialize)]
struct Metadata {
    /// A mapping from file paths to source URLs.
    map: std::collections::HashMap<PathBuf, String>,
}

impl Preprocessor for ExtraDocs {
    fn name(&self) -> &str {
        "typst-extra-docs"
    }

    fn run(&self, ctx: &PreprocessorContext, mut book: Book) -> Result<Book> {
        // Read data generated by `download.py`
        let meta = ctx.config.book.src.join("meta.json");
        let meta: Metadata = serde_json::from_reader(File::open(&meta).inspect_err(|e| {
            eprintln!("Failed to open {:?}: {e:?}", &meta);
        })?)?;

        book.for_each_chapter_mut(|chapter| {
            let Some(file) = &chapter.source_path else {
                return; // Skip draft chapters
            };
            let Some(source_url) = meta.map.get(file) else {
                return; // Skip chapters not generated by `download.py`
            };
            add_source_notice(chapter, source_url);
        });

        Ok(book)
    }

    fn supports_renderer(&self, renderer: &str) -> Result<bool> {
        Ok(renderer != "not-supported")
    }
}

/// Add a source URL notice to the chapter.
fn add_source_notice(chapter: &mut Chapter, source_url: &str) {
    // Insert a notice at the top of the chapter
    chapter.content = format!(
        r#"> [!NOTE]
> This is an _unofficial_ copy of [the file in Typst's official repository]({source_url}).

{}"#,
        chapter.content
    );
}
